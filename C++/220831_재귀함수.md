## 220831 재귀함수

### 코드는 실시간으로 변화하지 않는다.
* 변수에 들어있는 숫자들이 조정되면서 반복문을 돌아 원하는 값을 얻어내는 구조.  

* 내가 작성한 코드 안에 변수들이 존재하고   
    이들이 계속 변경 되면서 원하는 상황이 될 때까지   맞물려돌아가면서  
    원하는 결과를 도출해낼 수 있어야한다.  

✍ 다시한번 `변수`란 메모리 공간에 내가 이름을 준 것. 즉 **바뀔 수 있다.**

<br/>

### 함수에서 만든 변수(지역변수)는 어디에 있을까?
* 레지스터메모리에 잠시 저장했다가 사라진다.
* 함수가 종료되면 메인함수는 거기에서 값만 꺼내온다.  

<br/>

### 재귀함수 동작방식
* 재귀함수는 실행됐을때 스택 안에 스택이 계속 쌓이지 않고 새로운 스택으로 쌓여간다.

 * 문제는 함수가 쌓여가기만하고 종료될수 없다. 스택이 쌓여만 간다.  

* 그러다 한계치에 도달한다. 스택 메모리의 한계치에 도달하면 발생하는 에러가 **스택오버플로우**다.  
👉 재귀함수는 반드시 **탈출조건**이 필요하다.

 <br/>

 ### 재귀함수의 단점
* 성능이 많이 떨어지는 치명적인 문제가 있다.  

* 문제의 해결을 **스택메모리**에 쌓아가면서 각각의 스택에 남아있는 데이터들을 역으로 되돌아나오면서 재활용하는 방식이다.  

* 함수가 호출될때 발생하는 스택을 **마치 변수**처럼 사용하기때문에 **함수호출비용**과 **해제비용**이 든다.  

👉 이런것들이 함수의 **성능저하**를 일으킨다. -> 속도 느려짐

<br/>

 ### 그럼에도 재귀함수를 사용하는 이유는?
👉 **가독성**, **구현**의 용이

* **계층구조**를 표현해낼 때 좋다.
* 계층구조 형태로 데이터를 관리하는 **트리** 자료구조를 탐색하거나 트리의 후속자나 선행자를 찾을 때 사용한다.  
* 반복문으로 대체는 가능(스택or큐 활용필요)

### **❗ 편리하지만 설계에 주의!!**

<br/>

### + 피보나치 수열 구현을 통한 예시 

`피보나치 수열`
* 1 1 2 3 5 8 13 21 34 55...... 
* `n`번째 숫자를 얻고싶다.    

❕ 이 피보나치 수열 구현은 문제가 있다. -> 구현은 쉽지만 엄청느리다.

<br/>

### 반복문으로 구현예시 
```cpp
int Fibonacci(int _iNum)
{
	if (1 == _iNum || 2 == _iNum)
	{
		return 1;
	}

	int iPrev1 = 1;
	int iPrev2 = 1;
	int iValue = 0;

	for (int i = 0; i < _iNum; ++i)
	{
		iValue = iPrev1 + iPrev2;
		iPrev1 = iPrev2;
		iPrev2 = iValue;
	}

	return iValue;
}


int main()
{	
	iValue = Fibonacci(10);

	return 0;
}
```

<br/>

### 재귀함수로 구현예시
```cpp
int Fibonacci_Re(int _iNum)
{
	if (1 == _iNum || 2 == _iNum) //결국 탈출조건이 됨
	{
		return 1;
	}

	return Fibonacci_Re(_iNum - 1) + Fibonacci_Re(_iNum - 2);

}


int main()
{	
	iValue = Fibonacci_Re(7);

	return 0;
}
```


