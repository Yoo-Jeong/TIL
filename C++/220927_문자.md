# 220927 문자

## 메모리 영역
1. **스택**
2. **데이터**
3. **힙**
4. **ROM** (코드)  
    Read Only Memory (읽기전용)

<br>

읽기전용메모리에 들어가는 `코드`에 대한 내용을 할 것이다.  
먼저 문자파트에 대해 알아보자.  

## 문자
```cpp
char c = 1;
bool b = 1;
```
c는 인텔리센스에서 1옆에 이상한 뭔가를 더 보여주고있다.     b는 1은 1이라고 나오고 true라고 보고있다.  
👉 둘의 자료형의 특징 때문이다.



정수형 자료형 1byte중에 char자료형이 있다.  
이 자료형은 1byte사이즈를 가지고있다. 또한 정수타입.  

* `char`자료형은 문자를 표현하는데에 특화된 1byte 정수형 자료형.

똑같은 1byte 자료형 중에 `bool`자료형이 있었다.  
`bool`은 0이나 1만 저장하는 용도로 사용한다.(참, 거짓)

<br>

### 2byte크기인 문자를 표현하는 자료형도 있다.  
 ```cpp
wchar_t wc = 49;
short s = 49;
```
s는 인텔리센스에서 49가 보여진다.  
wc는 49만 보여주는게 아니라 숫자 1도 보여준다.  
👉 아스키코드를 보면 10진수로 49가 문자로치면 1이다.

<br>

## 컴퓨터에서 문자라는게 뭐지?
아스키코드표 같은 문자 이미지를 저장해놓은 표가 있다.  
문자의 그림 형태를 메모리에 저장시켜 놓고, 특정 숫자가 보이면 그 숫자에 매칭되는 표에 있는 문자를 보여주는 것이다.  

<br>

### 컴퓨터가 0과 1로만 되어있다는 이유?
우리가 문서워드나 메모장에 한글이나 영어로 타자를 쳐서 문자로 보고있다.  

그러나 실제로 우리가 보고있는 문자는 메모리 상에서는 01010101...같은 숫자 데이터들이다.  

예를 들어 우리가 a를 입력했다면 메모리상으로 2진수로 97이 적혀있는 것이다. 이를 화면에 출력하고 그려지는 과정에서 문자로 바꿔서 보여주는 것이다.

👉 데이터가 바뀐 것은 아닌데 이를 문자로 해석하겠다고 하는 순간 아스키코드표같은걸 참조해서 문자로 바꿔보면 의미있는 데이터가 된다.  

     ** 데이터는 바뀌지 않음!! 해석이 바뀐 것! **

<br>

## `1` 과 `"1"`은 다르다.
```cpp
char c = 1;
c = '1';
```
인텔리센스를 확인해보면 서로 다르다.  
위는 \x1  
아래는 49  

<br>

* 여기가 문자의 끝이다. 라는걸 알리기 위해 끝에 마침표 역할로 `0`을 넣는다.    

* 그럼 0에 대응 하는 문자도 있지 않을까?  -> `NUL`문자. 

* 메모리 안에 정수 0이 들어있으면 이를 문자로 봤을 땐 `nul문자` (널문자)라고 한다.  
    *공백문자랑 착각주의!*  

공백은 비어있는게 아니라 공백문자가 들어가있다. 이 값은 32.  

