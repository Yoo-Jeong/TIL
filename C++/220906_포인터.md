# 220906 포인터

## 포인터(pointer)란?
: 다른 변수의 주소를 저장하는 변수


`*` : 간접 참조 연산자 / 포인터가 가리키고 있는 곳의 값을 구한다. (value)  
`&` : 주소 연산자 / 변수의 주소를 구한다. (주소 참조)  


선언 방법 예제
```cpp
int *p;               // int형을 가리키는 포인터 p
char *pc;             //char형을 가리키는 포인터 pc
double *pd;           //double형을 가리키는 포인터 pd
```
 

사용 방법 예제
```cpp
int main(){

int i = 10;
int *p;        //int형 포인터 선언

p = &i;        //변수와 포인터 연결

cout << &i;   //변수의 주소가 출력된다
cout << p;    //포인터의 값 출력(변수 i의 값인 10이 아니라 메모리 주소가 출력된다)
cout << *p;   //10이 출력된다(포인터를 통한 간접참조값 출력)


*p = 20;      //포인터를 통한 간접참조로 변수의 값 변경(포인터p가 가리키는 위치에 20을 대입한다)
cout << i;    //20이 출력된다


return 0; 
}
```
<br/>

## 포인터를 사용하는 이유는?
포인터를 사용하는 이유는 메모리를 효율적으로 사용하기 위해서이다.

포인터는 메모리의 주소를 가지고 있는 `변수`이다.  
포인터가 어떻게 메모리를 효율적으로 사용하는지 알기 위해 우선 프로그램이 **메모리를 할당 받는 두 가지 방법**을 알아야한다.


### 정적(static) 메모리 할당  
* 프로그램이 시작되기 전에 메모리를 할당받아 크기가 정해진다.  
* 처음에 할당받은 크기보다 더 큰 입력이 들어온다면 처리하지 못한다.  
* 더 작은 입력이 들어온다면 남은 메모리 공간은 낭비된다.  

 
### 동적(dynamic) 메모리 할당  
* 프로그램 실행 도중에 메모리를 할당 받는다.  
* 필요한 만큼만 할당받아 사용하고 반납한다.  
* 메모리를 효율적으로 사용가능하다.  
* `new` 와 `delete` 키워드 사용.  

 
동적 메모리 할당 과정 (p.270)
```cpp
int *p;         //동적 메모리를 가리킬 포인터 준비
p = new int;    //1. 동적 메모리 할당
*p = 100;       //2. 동적 메모리 사용
delete p;       //3. 동적 메모리 반납
```

<br/>

## 포인터 연산

증감 연산자인 `++`와 `--`는 간접 참조 연산자인 `*`과 같이 사용될 수 있다.  

주의) 증감 연산자를 포인터(주소)에 적용할 수도 있고 포인터가 가리키는 값에 적용할 수도 있기에 잘 구별해서 사용해야한다.

 
연산자들의 우선순위는 다음과 같다.

1. 후위증감연산자  
2. `*`, 전위증감연산자

`*`과 전위증감연산자의 우선순위는 같다. 결합성을 보면 오른쪽에서 왼쪽으로 결합한다.

```cpp
*p++    //포인터를 한 칸 증가 후에 p가 가리키는 값 반환
(*p)++  //p가 가리키는 값을 증가
*++p    //포인터를 한 칸 증가 후에 p가 가리키는 값 반환
++*p    //p가 가리키는 값을 가져온 후에 그 값을 증가
```
뺄셈도 마찬가지이다.

 <br/>

## 포인터와 배열

사실상 배열의 이름은 포인터와 같은 역할을 한다. 따라서 배열의 이름은 첫 번째 배열 원소의 주소(`a[0]`)와 같다.

예제를 통한 확인 (p.265 / p_array2.cpp)
```cpp
int main(){
int a[] = {10, 20, 30, 40, 50}

cout << a << endl;
cout << a+1 << endl;
cout << *a << endl;
cout << *(a+1) <<endl;

return 0; 
} 

/* 출력결과
1245008
1245012
10
20
*/
```

 
출력결과를 보면 다음과 같은 사실을 알 수 있다.

* `*a`를 출력하면 주소값이 출력된다.

* `a+1`은 `a`보다 `4`가 크며 `a[1]`의 주소와 같다.

* `*a`는 배열의 이름이 포인터이므로 `a`가 가리키는 곳의 값인 `a[0]`와 같다.

* `*(a+1)`은 `a[1]`과 같다. (`a`가 포인터이므로 배열의 시작 주소에 `(1 * 배열원소의 크기)`값이 더해진다. 따라서 `a+1`은 `&a[1]`과 완전히 동일하다.)

<br/>

### 포인터 변수의 크기는?
[220907_포인터 변수의 크기.md](https://github.com/Yoo-Jeong/TIL/blob/master/C%2B%2B/220907_%ED%8F%AC%EC%9D%B8%ED%84%B0%20%EB%B3%80%EC%88%98%EC%9D%98%20%ED%81%AC%EA%B8%B0.md)


<br/>
 
## 자료구조 – 연결리스트(linked list)  
: `데이터`와 `next`(포인터)를 가지고있는 **노드가 한 줄로 연결되어있는 방식**으로 데이터를 저장하는 자료구조이다.  
마치 초중고등학교에서 볼 수 있었던 비상연락망처럼 한 사람이 자신 다음 출석번호인 사람의 연락처만을 알고있는 방식이다.

 
연결리스트의 구조를 간단하게 설명하면 다음과 같다.

* 각 요소는 `노드`(node)라고 한다.  
* 각 노드는 `데이터`, `next`(포인터) 쌍을 가진다.  
* 첫 번째 노드는 `head`라고 하며 데이터를 직접 저장하지 않고 리스트의 첫 번째 노드를 가리킨다.(head pointer)  
* 제일 마지막 노드는 `null포인터`를 저장한다.

<br/>
 
### 연결리스트의 특징
* 연결리스트는 크기를 미리 제한할 필요가 없고 동적인 삽입/삭제가 비교적 자유롭다.   
* 하지만 순차적으로 탐색하지 않으면 특정 위치의 요소에 접근할 수 없어 탐색속도가 느리다는 단점이 있다. 
* 탐색이나 정렬보다 삽입/삭제가 많을 경우에 사용하는 것이 좋다.

 

연결 리스트는 `스택(stack)`, `큐(queue)` 등의 자료구조들을 구현하는데 사용된다.

<br/>

---

```cpp
int main()
{	
	// 포인터 변수
	// 주소를 가리키는 변수
	// 자료형 + * 변수명
	// 해당 포인터에게 전달된 주소를 해석하는 단위
	int i = 100;
	float f = 3.f;

	int* pInt = &i;
	//int* pInt = &f; //오류
	int* pInt = (int*)&f; //강제캐스팅

	// 주소로 접근
	(*pInt) = 100;
	int i = *pInt;

	// 주소의 단위
	// BYTE


	return 0;
}

```


* 값이 바뀌는게 아님! 해석에 따라 달라지는것!


